# 모듈화 + 패키지
# 모듈 만들기, 테스트 코드 배치, 모듈 가져오기, 패키지 사용
# 모듈 => *.py ( ex) 파일명.py)
#         mod.py, __init__.py, p1.py, p2.py, ...
# 모듈화의 대상 => 대상, 함수, 클래스 <= 이런 요소를 가져다 내것처럼 사용가능
#                 PI,PI2,PI3, add(), XMan
# 패키지 => 유사한 기능끼리 묶어둔 디렉터리, 유틸리티, 통신, GUI등등 모아둔 것
#           a, b폴더가 해당된다.
#           패키지 폴더내에 존재하는 __init__.py 이 파일은 하위 호환을 위해서 python3.3이하 
#           에서는 모두 사용한다. 그리고, __init__.py는 곧 해당 패키지 자체를 의미한다
####################################################################################
# 땡기는 방법(자동완성은 꺼진상태에서)
# from 패키지.패키지....모듈 import 변수, 함수, 클래스(필요한것들 열거)
from a.b.mod import PI, add  # import: 가지고옴
print(PI)
print(add(1,2))

# 두번째 케이스 : from 패키지.패키지 import 변수, 함수, 클래스(필요한것들 열거)
# 경로상 마지막 패키지(b, 디렉토리)안에 있는 __init__.py에서 모듈을 가져온다
from a.b import PI2 as pi2
print(pi2)

# 패키지명은 절대로 . 들어가면 안된다!!
# 모듈명도 절대로 . 들어가면 안된다!!
from a import PI3
print(PI3)

# 별칭 => 이름이 너무 길어서라든지, 이름 변경을 해서 사용하고 싶다면
# 원래이름 as 별칭
from a import PI3 as pi # 소문자로 바꾸고 싶을 경우
print(pi)

# 가져올 모듈이 너무 많다. 다 가져왔으면 좋을 경우 => *
# 하위 호환을 위해서는
# __all__=['mod'] -> 파이썬 3.3 밑에 것에서는 이렇게 해야됨(b폴더의 __init__에서 확인해볼것)
from a.b import * # b 밑에 있는거 싹다 가져옴
print( mod.PI, PI2 ) # mod는 모듈명이기 때문에 . 찍고 PI로 들어가야 한다

# import만 사용시
import a.b.mod as m  # a.b.mod까지 작성하면 무엇을 지칭하는지 잘 모른다, 때문에 m으로 변경해줌
print( m.PI ) 

import a.b.mod as bm   
print( bm.PI )

# 모듈을 가져온다는 것은 해당 모듈을 실행한다라고 봐도 무방하다 -> 메모리 적제를 해야한
# 내가 만든 모듈같은 경우 의도하지 않은 코드가 실행될 수 있다
# => 테스트 할려고 만든 코드는 모듈 가져오기 수행시 실제로 구동되면 안된다
# => 이런 코드 처리가 필요하다 => __name__을 이용하여 처리한다
# __name__을 사용하는 모듈을 직접 구동하면 "__main__"으로 나오고,
# 모듈로 사용되면(즉, 다른 모듈이 가져다 쓰면) "모듈명"으로 나온다
# 즉, 직접쓰면 main으로 나오고, 땡겨쓰면 모듈명으로 나온다

from p13_mod import XMan
mu = XMan( '로건', 100, 50, 51)
print( mu )
print('p14 : __name__', __name__)

# p13_mod 수정후 실행 결과 확인할 것 -> 프롬프트 창에서 p13_mod 내용은 빠져있음